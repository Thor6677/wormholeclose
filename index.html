<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>W-Space Wormhole Closer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: Arial, sans-serif; margin: 1rem; max-width: 600px; }
    h1, h2 { text-align: center; }
    .step { display: none; }
    .step.active { display: block; }
    .wizard-nav { margin-top: 1.5rem; display: flex; justify-content: space-between; }
    button { padding: .5rem 1rem; }
    #suggestions { border: 1px solid #ccc; max-height: 150px; overflow-y: auto; margin-top: .5rem; }
    .suggestion { padding: .5rem; cursor: pointer; }
    .suggestion:hover { background: #eee; }
    pre { background: #f9f9f9; padding: 1rem; white-space: pre-wrap; }
    @media (max-width: 480px) {
      button { flex: 1; margin: .25rem 0; }
      .wizard-nav { flex-direction: column-reverse; }
    }
  </style>
</head>
<body>

  <h1>W-Space Wormhole Closer</h1>
  
  <!-- Step 1: Select Wormhole -->
  <div id="step-1" class="step active">
    <h2>Step 1: Choose Wormhole</h2>
    <input type="text" id="wh-search" placeholder="Type wormhole code…" autocomplete="off" />
    <div id="suggestions"></div>
    <div id="wh-details"></div>
  </div>
  
  <!-- Step 2: State & Goal -->
  <div id="step-2" class="step">
    <h2>Step 2: State &amp; Goal</h2>
    <label>
      Current Status:
      <select id="status-select">
        <option value="stable">Stable (100→50%)</option>
        <option value="unstable">Unstable (50→10%)</option>
        <option value="critical">Critical (10→0%)</option>
      </select>
    </label>
    <br><br>
    <label>
      Goal:
      <select id="goal-select">
        <option value="close">Close (0%)</option>
        <option value="crit">Crit (10%)</option>
      </select>
    </label>
  </div>

  <!-- Step 3: Enter Ship Mass -->
  <div id="step-3" class="step">
    <h2>Step 3: Enter Ship Mass</h2>
    <label>
      Cold Mass (kg):
      <input type="number" id="cold-mass" placeholder="e.g. 1650000" />
    </label>
    <br><br>
    <label>
      Hot Mass (kg):
      <input type="number" id="hot-mass" placeholder="e.g. 2475000" />
    </label>
  </div>

  <!-- Step 4: Initial Jump Plan -->
  <div id="step-4" class="step">
    <h2>Step 4: Initial Jump</h2>
    <p id="initial-summary"></p>
    <pre id="initial-steps"></pre>
  </div>

  <!-- Step 5: Return Jump (Interactive) -->
  <div id="step-5" class="step">
    <h2>Step 5: Return Jump</h2>
    <p>Select the hole’s observed state after your initial jump:</p>
    <label>
      Hole State:
      <select id="return-state">
        <option value="stable">Stable (50–100%)</option>
        <option value="unstable">Unstable (10–50%)</option>
        <option value="critical">Critical (0–10%)</option>
      </select>
    </label>
    <div id="return-suggestion" style="margin-top:1rem;"></div>
  </div>

  <!-- Wizard Navigation -->
  <div class="wizard-nav">
    <button id="btn-reset">Reset</button>
    <div>
      <button id="btn-back" disabled>Back</button>
      <button id="btn-next">Next</button>
    </div>
  </div>

  <script type="module">
    import { wormholes } from './data/wormholes.js';

    // State
    let step = 1, wh = null;
    let startMass = 0, goalMass = 0;
    let shipCount = 0, remAfterInit = 0;
    let retClose = {}, retCrit = {};

    // Elements
    const steps = {
      1: document.getElementById('step-1'),
      2: document.getElementById('step-2'),
      3: document.getElementById('step-3'),
      4: document.getElementById('step-4'),
      5: document.getElementById('step-5'),
    };
    const btnNext  = document.getElementById('btn-next');
    const btnBack  = document.getElementById('btn-back');
    const btnReset = document.getElementById('btn-reset');
    const whSearch = document.getElementById('wh-search');
    const suggest  = document.getElementById('suggestions');
    const whDetails= document.getElementById('wh-details');
    const statusSel= document.getElementById('status-select');
    const goalSel  = document.getElementById('goal-select');
    const coldIn   = document.getElementById('cold-mass');
    const hotIn    = document.getElementById('hot-mass');
    const initSum  = document.getElementById('initial-summary');
    const initSt   = document.getElementById('initial-steps');
    const returnSt = document.getElementById('return-state');
    const returnDiv= document.getElementById('return-suggestion');

    function show(n) {
      Object.values(steps).forEach(s => s.classList.remove('active'));
      steps[n].classList.add('active');
      btnBack.disabled = n === 1;
      btnNext.textContent = n === 5 ? 'Finish' : 'Next';
    }

    // Reset
    btnReset.onclick = () => {
      step = 1; wh = null;
      startMass = goalMass = 0;
      shipCount = remAfterInit = 0;
      retClose = retCrit = {};
      whSearch.value = '';
      suggest.innerHTML = whDetails.innerHTML = '';
      coldIn.value = hotIn.value = '';
      initSum.textContent = initSt.textContent = '';
      returnDiv.innerHTML = '';
      show(1);
    };

    // Back
    btnBack.onclick = () => {
      if (step > 1) show(--step);
    };

    // Next
    btnNext.onclick = () => {
      if (step === 1 && !wh) {
        alert('Select a wormhole'); return;
      }
      if (step === 2) {
        const pct = { stable: 1, unstable: .5, critical: .1 }[statusSel.value];
        startMass = Math.round(wh.totalMass * pct);
        goalMass  = goalSel.value === 'close'
          ? 0
          : Math.round(wh.totalMass * .1);
      }
      if (step === 3) {
        if (!coldIn.value || !hotIn.value) {
          alert('Enter both cold & hot mass'); return;
        }
        buildInitial();
      }
      if (step === 4) {
        prepareReturn();
        drawReturn();
      }
      if (step < 5) show(++step);
      else alert('Done! Reset to start again.');
    };

    // Step 1 search
    whSearch.oninput = () => {
      const q = whSearch.value.toUpperCase().trim();
      suggest.innerHTML = whDetails.innerHTML = '';
      wh = null;
      if (!q) return;
      wormholes
        .filter(x => x.type.startsWith(q))
        .slice(0, 8)
        .forEach(x => {
          const d = document.createElement('div');
          d.className = 'suggestion';
          d.textContent = x.type;
          d.onclick = () => selectWH(x);
          suggest.appendChild(d);
        });
    };

    function selectWH(x) {
      wh = { ...x };
      whSearch.value = x.type;
      suggest.innerHTML = '';
      let html = `<strong>${x.type}</strong><ul>
        <li>From: ${x.from || '—'}</li>
        <li>To: ${x.to}</li>
        <li>Total Mass: ${x.totalMass.toLocaleString()}</li>
        <li>Max Jump Mass: ${x.maxIndividualMass.toLocaleString()}</li>
        <li>Class: ${x.classification}</li>
        <li>Max Stable Time: ${x.maxStableTime} h</li>`;
      if (x.massRegeneration) {
        html += `<li>Regen: ${x.massRegeneration.toLocaleString()}/s</li>`;
      }
      html += `</ul>`;
      whDetails.innerHTML = html;
    }

// Step 4: dynamic initial jump plan
function buildInitialPlan() {
  const cold   = parseInt(coldInput.value, 10);
  const hot    = parseInt(hotInput.value, 10);
  const total  = currentWH.totalMass;
  const maxInd = currentWH.maxIndividualMass;
  const status = statusSelect.value;

  // Determine the *next* threshold after your current status:
  let nextThreshold;
  if (status === 'stable')   nextThreshold = total * 0.5;
  else if (status === 'unstable') nextThreshold = total * 0.1;
  else /* critical */         nextThreshold = goalMass; // usually 0

  // How much mass we must remove to cross into that band:
  const requiredRemoval = Math.max(0, startMass - nextThreshold) + 1;

  // Sanity check: ensure neither your cold nor hot mass exceed the hole's limit:
  if (cold > maxInd || hot > maxInd) {
    alert(`Error: Your ship mass (${cold}/${hot} kg) exceeds this hole's max per-ship mass (${maxInd.toLocaleString()} kg).`);
    return;
  }

  // Search for the *smallest* N where some combination (h hot + c cold) ≥ requiredRemoval.
  let best = null;
  const MAX_SHIPS = 20;  // arbitrary cap to avoid infinite loops
  for (let N = 1; N <= MAX_SHIPS; N++) {
    for (let h = 0; h <= N; h++) {
      const c      = N - h;
      const moved  = h * hot + c * cold;
      // also ensure that each *individual* hot/cold ≤ maxInd (we already did)
      if (moved >= requiredRemoval) {
        if (
          best === null ||
          N < best.N ||
          (N === best.N && moved < best.removal)
        ) {
          best = { N, coldCount: c, hotCount: h, removal: moved };
        }
      }
    }
    if (best) break;  // once we have the minimal N, stop
  }

  // Fallback: if we never found a tight fit, just maximize per-ship mass
  if (!best) {
    // pick the pattern with largest per-round-trip mass:
    const patterns = [
      { c: 0, h: 1, per: hot },
      { c: 1, h: 0, per: cold }
    ];
    patterns.sort((a,b) => b.per - a.per);
    const perShip     = patterns[0].per;
    const shipsNeeded = Math.ceil(requiredRemoval / perShip);
    best = {
      N: shipsNeeded,
      coldCount: patterns[0].c * shipsNeeded,
      hotCount:  patterns[0].h * shipsNeeded,
      removal: patterns[0].per * shipsNeeded
    };
  }

  // Commit to state
  shipCount     = best.N;
  const moved   = best.removal;
  remAfterInit  = startMass - moved;

  // Render to user
  initialSummary.textContent =
    `Use ${shipCount} ship${shipCount>1?'s':''}: ` +
    `${best.coldCount} cold & ${best.hotCount} hot for the test jump.`;
  initialSteps.textContent = [
    `Starting mass: ${startMass.toLocaleString()} kg`,
    `Mass moved:     ${moved.toLocaleString()} kg`,
    `Est. remaining: ${remAfterInit.toLocaleString()} kg`
  ].join('\n');
}

    // Prepare return data
    function prepareReturn() {
      const cold = +coldIn.value, hot = +hotIn.value;
      const total = wh.totalMass;
      const th10  = Math.round(total * .1);
      const needClose = remAfterInit - 0;
      const needCrit  = remAfterInit - th10;
      retClose = calc(needClose);
      retCrit  = calc(needCrit);
    }

    function calc(diff) {
      const cold = +coldIn.value, hot = +hotIn.value;
      for (let h = 0; h <= shipCount; h++) {
        const c = shipCount - h;
        if (h*hot + c*cold >= diff) return { cold: c, hot: h };
      }
      return { cold: 0, hot: shipCount };
    }

    // Draw on change
    returnSt.addEventListener('change', drawReturn);

    function drawReturn() {
      const st = returnSt.value;
      const cClose = passable(retClose), cCrit = passable(retCrit);
      returnDiv.innerHTML = `
        <p><strong>If ${st.charAt(0).toUpperCase()+st.slice(1)}:</strong></p>
        <p>To Close: ${retClose.cold} cold & ${retClose.hot} hot` +
        (cClose.stranded
          ? ` → ${cClose.stranded} ship${cClose.stranded>1?'s':''} may be stranded`
          : ` (all will pass)`) +
        `</p>
        <p>To Crit:  ${retCrit.cold} cold & ${retCrit.hot} hot` +
        (cCrit.stranded
          ? ` → ${cCrit.stranded} may be stranded`
          : ` (all will pass)`) +
        `</p>
      `;
    }

    function passable(plan) {
      let rem = remAfterInit;
      const cold = +coldIn.value, hot = +hotIn.value;
      const hPass = Math.min(plan.hot, Math.floor(rem/hot));
      rem -= hPass * hot;
      const cPass = Math.min(plan.cold, Math.floor(rem/cold));
      const stranded = shipCount - (hPass + cPass);
      return { stranded };
    }

    // Initialize
    show(1);
  </script>

</body>
</html>
